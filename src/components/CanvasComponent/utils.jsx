// Converts the points generated by perfect-freehand into an SVG path string
export function getSvgPathFromStroke(stroke) {
  if (!stroke.length) return ""; // If no stroke points, return an empty string

  // Generate path data by creating a quadratic curve between each point
  const d = stroke.reduce(
    (acc, [x0, y0], i, arr) => {
      const [x1, y1] = arr[(i + 1) % arr.length]; // Get the next point
      acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2); // Create a midpoint between the points
      return acc;
    },
    ["M", ...stroke[0], "Q"] // Move to the first point and start the quadratic curve
  );

  d.push("Z"); // Close the path
  return d.join(" "); // Return the generated SVG path as a string
}

// Function to open an IndexedDB database and create an object store if it doesn't exist
export const openDB = (dbName, storeName) => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(dbName, 1);

    // This event is triggered if the database needs to be upgraded (e.g., when it's created)
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      db.createObjectStore(storeName); // Create an object store
    };

    // This event is triggered when the database is successfully opened
    request.onsuccess = (event) => {
      resolve(event.target.result); // Resolve the promise with the database instance
    };

    // This event is triggered if there's an error opening the database
    request.onerror = (event) => {
      reject(event.target.error); // Reject the promise with the error
    };
  });
};

// Function to get a value from the IndexedDB
export const getFromDB = (db, storeName, key) => {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly'); // Start a read-only transaction
    const store = transaction.objectStore(storeName); // Get the object store
    const request = store.get(key); // Get the value by key

    // This event is triggered when the value is successfully retrieved
    request.onsuccess = (event) => {
      resolve(event.target.result); // Resolve the promise with the retrieved value
    };

    // This event is triggered if there's an error retrieving the value
    request.onerror = (event) => {
      reject(event.target.error); // Reject the promise with the error
    };
  });
};

// Function to save a value to the IndexedDB
export const saveToDB = (db, storeName, key, value) => {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite'); // Start a read-write transaction
    const store = transaction.objectStore(storeName); // Get the object store
    const request = store.put(value, key); // Save the value with the specified key

    // This event is triggered when the value is successfully saved
    request.onsuccess = () => {
      resolve(); // Resolve the promise
    };

    // This event is triggered if there's an error saving the value
    request.onerror = (event) => {
      reject(event.target.error); // Reject the promise with the error
    };
  });
};